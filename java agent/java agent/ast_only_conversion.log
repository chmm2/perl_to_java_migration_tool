2025-07-21 15:18:36,771 [INFO] Available node labels: ['PERL_FILE', 'USE_STATEMENT', 'PACKAGE', 'METHOD', 'SCRIPT_EXECUTION', 'Node', 'CLASS', 'FIELD', 'SUB_DEFINITION', 'FILE']
2025-07-21 15:18:36,788 [INFO] Available relationship types: ['USES_MODULE', 'CONTAINS_PACKAGE', 'HAS_METHOD', 'HAS_SCRIPT', 'CALLS_METHOD', 'INTRA_METHOD_CALL']
2025-07-21 15:18:39,631 [INFO] Found 3 files in database
2025-07-21 15:18:39,632 [INFO] 
================================================================================
2025-07-21 15:18:39,632 [INFO] 🚀 AST-ONLY PERL TO JAVA CONVERSION SYSTEM
2025-07-21 15:18:39,633 [INFO]    💎 NO PERL SOURCE CODE REQUIRED
2025-07-21 15:18:39,634 [INFO] ================================================================================
2025-07-21 15:18:39,634 [INFO] 📁 Found 3 files to convert:
2025-07-21 15:18:39,635 [INFO]    1. Employee.pm
2025-07-21 15:18:39,635 [INFO]    2. Manager.pm
2025-07-21 15:18:39,636 [INFO]    3. main.pl
2025-07-21 15:18:39,636 [INFO] ================================================================================
2025-07-21 15:18:39,637 [INFO] 🤖 Model: llama3-70b-8192
2025-07-21 15:18:39,638 [INFO] 🌡️  Temperature: 0.1
2025-07-21 15:18:39,639 [INFO] 🎯 AST-Only Features:
2025-07-21 15:18:39,639 [INFO]    • Comprehensive AST data extraction
2025-07-21 15:18:39,640 [INFO]    • Intelligent field and method inference
2025-07-21 15:18:39,641 [INFO]    • Design pattern detection
2025-07-21 15:18:39,641 [INFO]    • Complete business logic generation
2025-07-21 15:18:39,642 [INFO]    • NO Perl source code access required
2025-07-21 15:18:39,642 [INFO] ================================================================================

2025-07-21 15:18:39,642 [INFO] 
============================================================
2025-07-21 15:18:39,643 [INFO] 🔄 AST-only conversion 1/3: Employee.pm
2025-07-21 15:18:39,644 [INFO] ============================================================
2025-07-21 15:18:39,756 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: ACCESSES_FIELD)} {position: line: 14, column: 34, offset: 584} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,759 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: return_type)} {position: line: 43, column: 39, offset: 1753} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,760 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: start_line)} {position: line: 44, column: 38, offset: 1803} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,762 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: HAS_PARAMETER)} {position: line: 13, column: 34, offset: 527} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,765 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: CONTAINS)} {position: line: 22, column: 34, offset: 963} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,768 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: DECLARES)} {position: line: 25, column: 34, offset: 1073} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,771 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: end_line)} {position: line: 45, column: 36, offset: 1850} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:39,775 [INFO] ✅ Enhanced AST analysis for: examples\Employee.pm
2025-07-21 15:18:39,775 [INFO] 📱 Application Type: object_class
2025-07-21 15:18:39,776 [INFO] 🏢 Business Domain: employee
2025-07-21 15:18:39,776 [INFO] 🔄 Conversion Strategy: oop_class
2025-07-21 15:18:39,777 [INFO] 📦 Packages: 1
2025-07-21 15:18:39,777 [INFO] 🔧 Methods: 3
2025-07-21 15:18:39,778 [INFO] 📥 Imports: 0
2025-07-21 15:18:39,780 [INFO] ✓ Completed step: data_retrieval
2025-07-21 15:18:39,782 [INFO] 📊 Analysis Input - Packages: 1, Methods: 3, Imports: 0
2025-07-21 15:18:39,783 [WARNING] LLM analysis failed: 'EnhancedGroqLLM' object has no attribute 'analyze_perl_structure', using AST-based analysis
2025-07-21 15:18:39,786 [INFO] 🎯 Analysis Results - Subroutines: 3
2025-07-21 15:18:39,790 [INFO] ✓ Completed step: perl_analysis
2025-07-21 15:18:39,791 [INFO] 🎯 File archetype determined: module
2025-07-21 15:18:39,792 [INFO] 🏭 Processing as module/class: Employee
2025-07-21 15:18:39,793 [INFO] 📊 Analysis data - Packages: 1, Methods: 3, Subroutines: 3
2025-07-21 15:18:39,793 [INFO] 🤖 Attempting LLM-based code generation...
2025-07-21 15:18:41,952 [INFO] HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-07-21 15:18:41,959 [INFO] ✅ LLM generation successful: 423 chars
2025-07-21 15:18:41,961 [INFO] ✓ Completed step: code_generation
2025-07-21 15:18:41,964 [INFO] ✅ Code assurance completed - Quality: 10/10, Blocking errors: 0
2025-07-21 15:18:41,967 [INFO] ✓ Completed step: code_assurance
2025-07-21 15:18:41,969 [INFO] Attempting code enhancement...
2025-07-21 15:18:44,258 [INFO] HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-07-21 15:18:44,262 [INFO] Enhancement declined - keeping original code
2025-07-21 15:18:44,262 [INFO] ✅ Final validation successful - Quality: 10/10
2025-07-21 15:18:44,264 [INFO] ✓ Completed step: final_validation
2025-07-21 15:18:44,334 [INFO] Saved Java code to: output\success\Employee.java
2025-07-21 15:18:44,338 [INFO] Saved conversion report to: output\success\Employee_report.json
2025-07-21 15:18:44,338 [INFO] ✅ SUCCESS - Employee.pm
2025-07-21 15:18:44,339 [INFO] 📊 Generated 423 characters (19 lines)
2025-07-21 15:18:44,339 [INFO] 🔍 Analysis: high
2025-07-21 15:18:44,339 [INFO] ⏸️  Waiting 3 seconds before next batch...
2025-07-21 15:18:47,346 [INFO] 
============================================================
2025-07-21 15:18:47,347 [INFO] 🔄 AST-only conversion 2/3: Manager.pm
2025-07-21 15:18:47,347 [INFO] ============================================================
2025-07-21 15:18:47,456 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: ACCESSES_FIELD)} {position: line: 14, column: 34, offset: 584} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,459 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: return_type)} {position: line: 43, column: 39, offset: 1753} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,461 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: start_line)} {position: line: 44, column: 38, offset: 1803} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,464 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: HAS_PARAMETER)} {position: line: 13, column: 34, offset: 527} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,466 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: CONTAINS)} {position: line: 22, column: 34, offset: 963} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,468 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: DECLARES)} {position: line: 25, column: 34, offset: 1073} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,472 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: end_line)} {position: line: 45, column: 36, offset: 1850} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:47,476 [INFO] ✅ Enhanced AST analysis for: examples\Manager.pm
2025-07-21 15:18:47,477 [INFO] 📱 Application Type: complex_module
2025-07-21 15:18:47,478 [INFO] 🏢 Business Domain: employee
2025-07-21 15:18:47,479 [INFO] 🔄 Conversion Strategy: single_class
2025-07-21 15:18:47,480 [INFO] 📦 Packages: 1
2025-07-21 15:18:47,480 [INFO] 🔧 Methods: 6
2025-07-21 15:18:47,480 [INFO] 📥 Imports: 0
2025-07-21 15:18:47,483 [INFO] ✓ Completed step: data_retrieval
2025-07-21 15:18:47,485 [INFO] 📊 Analysis Input - Packages: 1, Methods: 6, Imports: 0
2025-07-21 15:18:47,486 [WARNING] LLM analysis failed: 'EnhancedGroqLLM' object has no attribute 'analyze_perl_structure', using AST-based analysis
2025-07-21 15:18:47,488 [INFO] 🎯 Analysis Results - Subroutines: 6
2025-07-21 15:18:47,489 [INFO] ✓ Completed step: perl_analysis
2025-07-21 15:18:47,490 [INFO] 🎯 File archetype determined: module
2025-07-21 15:18:47,491 [INFO] 🏭 Processing as module/class: Manager
2025-07-21 15:18:47,492 [INFO] 📊 Analysis data - Packages: 1, Methods: 6, Subroutines: 6
2025-07-21 15:18:47,493 [INFO] 🤖 Attempting LLM-based code generation...
2025-07-21 15:18:49,670 [INFO] HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-07-21 15:18:49,672 [INFO] ✅ LLM generation successful: 913 chars
2025-07-21 15:18:49,674 [INFO] ✓ Completed step: code_generation
2025-07-21 15:18:49,676 [INFO] ✅ Code assurance completed - Quality: 10/10, Blocking errors: 0
2025-07-21 15:18:49,679 [INFO] ✓ Completed step: code_assurance
2025-07-21 15:18:49,680 [INFO] Attempting code enhancement...
2025-07-21 15:18:51,901 [INFO] HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-07-21 15:18:51,904 [INFO] ✅ Code enhancement successful
2025-07-21 15:18:51,905 [INFO] ✅ Final validation successful - Quality: 10/10
2025-07-21 15:18:51,906 [INFO] ✓ Completed step: final_validation
2025-07-21 15:18:51,910 [INFO] Saved Java code to: output\success\Manager.java
2025-07-21 15:18:51,913 [INFO] Saved conversion report to: output\success\Manager_report.json
2025-07-21 15:18:51,916 [INFO] ✅ SUCCESS - Manager.pm
2025-07-21 15:18:51,918 [INFO] 📊 Generated 1,541 characters (61 lines)
2025-07-21 15:18:51,919 [INFO] 🔍 Analysis: high
2025-07-21 15:18:51,919 [INFO] ⏸️  Waiting 3 seconds before next batch...
2025-07-21 15:18:54,927 [INFO] 
============================================================
2025-07-21 15:18:54,928 [INFO] 🔄 AST-only conversion 3/3: main.pl
2025-07-21 15:18:54,928 [INFO] ============================================================
2025-07-21 15:18:55,129 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: ACCESSES_FIELD)} {position: line: 14, column: 34, offset: 584} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,131 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: return_type)} {position: line: 43, column: 39, offset: 1753} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,134 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: start_line)} {position: line: 44, column: 38, offset: 1803} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,136 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: HAS_PARAMETER)} {position: line: 13, column: 34, offset: 527} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,139 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: CONTAINS)} {position: line: 22, column: 34, offset: 963} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,143 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: DECLARES)} {position: line: 25, column: 34, offset: 1073} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,146 [WARNING] Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: end_line)} {position: line: 45, column: 36, offset: 1850} for query: '\n            MATCH (f:FILE)\n            WHERE f.source_file = $file_path OR f.name = $file_path\n            \n            // Get all nodes connected to this file\n            OPTIONAL MATCH (f)-[r1]-(n1)\n            OPTIONAL MATCH (f)-[r2]-(n2)-[r3]-(n3)\n            OPTIONAL MATCH (f)-[r4]-(n4)-[r5]-(n5)-[r6]-(n6)\n            \n            // Get packages and their details\n            OPTIONAL MATCH (f)-[:CONTAINS_PACKAGE]->(p:PACKAGE)\n            OPTIONAL MATCH (p)-[:HAS_METHOD]->(m:METHOD)\n            OPTIONAL MATCH (m)-[:HAS_PARAMETER]->(param)\n            OPTIONAL MATCH (m)-[:ACCESSES_FIELD]->(field)\n            OPTIONAL MATCH (m)-[:CALLS]->(called_method)\n            \n            // Get use statements and imports\n            OPTIONAL MATCH (f)-[:USES_MODULE]->(u:USE_STATEMENT)\n            \n            // Get script executions and control structures\n            OPTIONAL MATCH (p)-[:HAS_SCRIPT]->(s:SCRIPT_EXECUTION)\n            OPTIONAL MATCH (f)-[:CONTAINS]->(stmt)\n            \n            // Get any variables or constants\n            OPTIONAL MATCH (f)-[:DECLARES]->(var)\n            \n            RETURN f.source_file AS filePath,\n                   f.name AS fileName,\n                   f.file_type AS fileType,\n                   \n                   // Package information\n                   collect(DISTINCT {\n                       name: p.name,\n                       type: labels(p)[0]\n                   }) AS packages,\n                   \n                   // Method information\n                   collect(DISTINCT {\n                       name: m.name,\n                       full_name: m.full_name,\n                       body: m.body,\n                       parameters: m.parameters,\n                       return_type: m.return_type,\n                       start_line: m.start_line,\n                       end_line: m.end_line,\n                       id: m.id\n                   }) AS methods,\n                   \n                   // Import information\n                   collect(DISTINCT {\n                       module: u.module,\n                       name: u.name,\n                       type: u.type\n                   }) AS imports,\n                   \n                   // Script execution patterns\n                   collect(DISTINCT {\n                       name: s.name,\n                       body: s.body,\n                       type: labels(s)[0],\n                       id: s.id\n                   }) AS scripts,\n                   \n                   // All connected nodes for pattern analysis\n                   collect(DISTINCT {\n                       labels: labels(n1),\n                       properties: properties(n1),\n                       relationship: type(r1)\n                   }) AS allNodes,\n                   \n                   // Statement and control structure information\n                   collect(DISTINCT {\n                       labels: labels(stmt),\n                       properties: properties(stmt)\n                   }) AS statements,\n                   \n                   // Variable declarations\n                   collect(DISTINCT {\n                       labels: labels(var),\n                       properties: properties(var)\n                   }) AS variables\n            '
2025-07-21 15:18:55,150 [INFO] ✅ Enhanced AST analysis for: examples\main.pl
2025-07-21 15:18:55,152 [INFO] 📱 Application Type: utility_module
2025-07-21 15:18:55,154 [INFO] 🏢 Business Domain: employee
2025-07-21 15:18:55,154 [INFO] 🔄 Conversion Strategy: single_class
2025-07-21 15:18:55,155 [INFO] 📦 Packages: 1
2025-07-21 15:18:55,156 [INFO] 🔧 Methods: 0
2025-07-21 15:18:55,157 [INFO] 📥 Imports: 5
2025-07-21 15:18:55,159 [INFO] ✓ Completed step: data_retrieval
2025-07-21 15:18:55,160 [INFO] 📊 Analysis Input - Packages: 1, Methods: 0, Imports: 5
2025-07-21 15:18:55,161 [WARNING] LLM analysis failed: 'EnhancedGroqLLM' object has no attribute 'analyze_perl_structure', using AST-based analysis
2025-07-21 15:18:55,162 [INFO] 🎯 Analysis Results - Subroutines: 0
2025-07-21 15:18:55,164 [INFO] ✓ Completed step: perl_analysis
2025-07-21 15:18:55,166 [INFO] 🎯 File archetype determined: module
2025-07-21 15:18:55,169 [INFO] 🏭 Processing as module/class: Main
2025-07-21 15:18:55,170 [INFO] 📊 Analysis data - Packages: 1, Methods: 0, Subroutines: 0
2025-07-21 15:18:55,171 [INFO] 📝 Generating comprehensive scaffold from analysis data
2025-07-21 15:18:55,173 [INFO] 📊 Final generation: 520 characters (26 lines)
2025-07-21 15:18:55,175 [INFO] ✓ Completed step: code_generation
2025-07-21 15:18:55,179 [INFO] ✅ Code assurance completed - Quality: 10/10, Blocking errors: 0
2025-07-21 15:18:55,182 [INFO] ✓ Completed step: code_assurance
2025-07-21 15:18:55,184 [INFO] Attempting code enhancement...
2025-07-21 15:18:58,188 [INFO] HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-07-21 15:18:58,192 [INFO] ✅ Code enhancement successful
2025-07-21 15:18:58,192 [INFO] ✅ Final validation successful - Quality: 10/10
2025-07-21 15:18:58,193 [INFO] ✓ Completed step: final_validation
2025-07-21 15:18:58,199 [INFO] Saved Java code to: output\success\main.java
2025-07-21 15:18:58,201 [INFO] Saved conversion report to: output\success\main_report.json
2025-07-21 15:18:58,206 [INFO] ✅ SUCCESS - main.pl
2025-07-21 15:18:58,206 [INFO] 📊 Generated 1,866 characters (61 lines)
2025-07-21 15:18:58,207 [INFO] 🔍 Analysis: basic
2025-07-21 15:18:58,207 [INFO] 
================================================================================
2025-07-21 15:18:58,208 [INFO] 📊 AST-ONLY CONVERSION RESULTS
2025-07-21 15:18:58,209 [INFO] ================================================================================
2025-07-21 15:18:58,209 [INFO] 🎯 Success Rate: 100.0% (3/3)
2025-07-21 15:18:58,209 [INFO] ⏱️  Processing Time: 18.56 seconds
2025-07-21 15:18:58,210 [INFO] ⚡ Average Time/File: 6.19 seconds
2025-07-21 15:18:58,212 [INFO] 📝 Total Java Generated:
2025-07-21 15:18:58,212 [INFO]    • 3,830 characters
2025-07-21 15:18:58,212 [INFO]    • 141 lines of code
2025-07-21 15:18:58,213 [INFO] 🔍 Analysis Quality:
2025-07-21 15:18:58,213 [INFO]    • High-quality analyses: 2/3
2025-07-21 15:18:58,213 [INFO]    • Total fix attempts: 0
2025-07-21 15:18:58,213 [INFO] 💾 Output: output/
2025-07-21 15:18:58,214 [INFO] ⭐ AST-only conversion - No Perl source required!
2025-07-21 15:18:58,214 [INFO] ================================================================================

2025-07-21 15:18:58,214 [INFO] 📋 DETAILED CONVERSION RESULTS:
2025-07-21 15:18:58,215 [INFO] --------------------------------------------------------------------------------
2025-07-21 15:18:58,226 [INFO]  1. ✅ Employee.pm                         (423 chars, high analysis)
2025-07-21 15:18:58,227 [INFO]     📌 Generated using advanced LLM analysis, Moderate code size: 4...
2025-07-21 15:18:58,228 [INFO]  2. ✅ Manager.pm                          (1,541 chars, high analysis)
2025-07-21 15:18:58,229 [INFO]     📌 Generated using advanced LLM analysis, Moderate code size: 9...
2025-07-21 15:18:58,230 [INFO]  3. ✅ main.pl                             (1,866 chars, basic analysis)
2025-07-21 15:18:58,230 [INFO]     📌 Generated comprehensive scaffold from AST analysis, Moderate...
2025-07-21 15:18:58,231 [INFO] --------------------------------------------------------------------------------
2025-07-21 15:18:58,233 [INFO] 📄 AST-only JSON summary saved to: output\ast_only_conversion_summary.json
2025-07-21 15:18:58,235 [INFO] 📄 Text summary saved to: output\conversion_summary.txt
2025-07-21 15:18:58,236 [INFO] 
🎉 AST-only conversion completed successfully!
2025-07-21 15:18:58,236 [INFO] ✨ 3 files converted to Java without Perl source
2025-07-21 15:18:58,237 [INFO] 📁 Check 'output/success/' for generated files
2025-07-21 15:18:58,237 [INFO] 🏆 Powered by intelligent AST analysis!
2025-07-21 15:18:58,238 [INFO] 
🔌 AST-only conversion system closed gracefully.
